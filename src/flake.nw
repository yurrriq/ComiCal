\section{Nix flake}

The flake is comprised of a \nix{description},
\hyperref[subsec:flake-inputs]{\nix{inputs}}, and
\hyperref[subsec:flake-outputs]{\nix{outputs}}.

<<flake.nix>>=
{
  description = "Track the publish dates of your favorite comics";

  inputs = {
    <<inputs>>
  };

  outputs = { self, emacs-overlay, flake-utils, nixpkgs }:
    {
      <<Top-level outputs>>
    } // flake-utils.lib.eachSystem [ "x86_64-linux" ] (system:
      let
        pkgs = import nixpkgs {
          overlays = [ self.overlay ];
          inherit system;
        };
      in
      {
        <<Per-system outputs>>
      });
}
@


\subsection{Inputs}
\label{subsec:flake-inputs}

The \hrefootnote{https://github.com/nix-community/emacs-overlay}{Emacs overlay}
\say{comes with extra functions to generate an Emacs closure from various types
of dependency declaration.} Notably, \nix{emacsWithPackagesFromUsePackage},
which generates an Emacs closure from an Emacs config file, by way of
\hrefootnote{https://jwiegley.github.io/use-package/}{\elisp{use-package}}.  See
\hyperref[sec:emacs]{the Emacs section} on page~\pageref{sec:emacs} for usage.

<<inputs>>=
emacs-overlay.url = "github:nix-community/emacs-overlay";
@

\todoo{Describe flake-utils}

<<inputs>>=
flake-utils.url = "github:numtide/flake-utils";
@

Pin a version of the Nix package collection.

<<inputs>>=
nixpkgs.url = "github:nixos/nixpkgs/release-22.05";
@


\subsection{Outputs}
\label{subsec:flake-outputs}

Use
\hrefootnote{https://github.com/NixOS/nixpkgs/commit/c3b35f21}{\nix{composeManyExtensions}}
to compose all the [[<<overlays>>]] into one.

<<Top-level outputs>>=
overlay = nixpkgs.lib.composeManyExtensions (nixpkgs.lib.attrValues self.overlays);

overlays = {
  <<overlays>>
};
@

Override \nix{haskellPackages} to include this one.

<<overlays>>=
haskellPackages = final: prev: {
  haskellPackages = prev.haskellPackages.override {
    overrides = hfinal: hprev: {
      ComiCal = hprev.callCabal2nix "ComiCal" self { };
    };
  };
};
@

Build \hrefootnote{https://www.gnu.org/software/emacs/}{Emacs} with a
deterministic package set.

<<overlays>>=
myEmacs = nixpkgs.lib.composeExtensions emacs-overlay.overlay (final: prev: {
  myEmacs = prev.emacsWithPackagesFromUsePackage {
    alwaysEnsure = true;
    config = ./emacs.el;
  };
});
@

Define the ComiCal app, and make it the default.

<<Per-system outputs>>=
apps.ComiCal = flake-utils.lib.mkApp {
  drv = pkgs.haskell.lib.justStaticExecutables self.defaultPackage.${system};
};
defaultApp = self.apps.${system}.ComiCal;
@

Make ComiCal the default package, too.

<<Per-system outputs>>=
defaultPackage = self.packages.${system}.ComiCal;
@

Define the default \nix{devShell}, which includes all the tools necessary to
build the binary, Haskell documentation, and this PDF.

<<Per-system outputs>>=
devShell = pkgs.mkShell {
  FONTCONFIG_FILE = pkgs.makeFontsConf {
    fontDirectories = [ pkgs.iosevka ];
  };

  buildInputs = with pkgs; [
    cabal-install
    ghcid
    haskell-language-server
    haskellPackages.ormolu
    haskellPackages.pointfree
    hlint
    myEmacs
    nixpkgs-fmt
    noweb
    pre-commit
    pythonPackages.pygments
    pythonPackages.pywatchman
    rnix-lsp
    semver-tool
    (
      texlive.combine {
        inherit noweb;
        inherit (texlive) scheme-small
          catchfile
          datetime
          dirtytalk
          fancyref
          fmtcount
          framed
          fvextra
          hardwrap
          latexmk
          mathpazo
          minted
          titlesec
          todonotes
          tufte-latex
          xetex
          xstring
          ;
      }
    )
    which
  ] ++ self.defaultPackage.${system}.env.nativeBuildInputs;
};
@

Output the ComiCal derivation.

<<Per-system outputs>>=
packages = { inherit (pkgs.haskellPackages) ComiCal; };
@

%% Local Variables:
%% noweb-code-mode: nix-mode
%% End:
