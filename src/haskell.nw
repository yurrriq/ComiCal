\section{Haskell}

\subsection{The ComiCal.App module}

Define one of the fundamental data types to model a comic publisher. Each
publisher is a record composed of a \hs{scraper :: Scraper} for extracting data
from their website, and functions to fetch the publish dates of collections and
single issues.

<<The Publisher data type>>=
data Publisher = Publisher
  { getCollections :: ComiCalApp Series,
    getIssues :: ComiCalApp Series,
    scraper :: Scraper
  }
@ %def Publisher
@ %def getCollections
@ %def getIssues
@ %def scraper

<<The ComiCalApp newtype>>=
newtype ComiCalApp a = ComiCalApp
  {runApp :: ReaderT (Text, Publisher) (LoggingT IO) a}
  deriving
    ( Functor,
      Applicative,
      Monad,
      MonadLogger,
      MonadIO,
      MonadReader (Text, Publisher),
      MonadFail,
      MonadThrow
    )
@ %def ComiCalApp

<<Running the app>>=
runComiCalApp :: (Publisher -> ComiCalApp a) -> Publisher -> Text -> IO a
runComiCalApp getter publisher =
  runStderrLoggingT
    . runReaderT (runApp (getter publisher))
    . (,publisher)
@ %def runComiCalApp

<<lib/ComiCal/App.hs>>=
{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE TupleSections #-}

-- |
-- Module      : ComiCal.App
-- Copyright   : (c) Eric Bailey, 2019-2021
-- License     : MIT
-- Maintainer  : eric@ericb.me
-- Stability   : experimental
-- Portability : POSIX
module ComiCal.App
  ( ComiCalApp,
    runComiCalApp,
    Publisher (..),
  )
where

import ComiCal.Types (Scraper, Series)
import Control.Monad.Catch (MonadThrow)
import Control.Monad.Logger (LoggingT, MonadLogger, runStderrLoggingT)
import Control.Monad.Reader (MonadIO, MonadReader, ReaderT (..))
import Data.Text (Text)

<<The ComiCalApp newtype>>

<<Running the app>>

<<The Publisher data type>>
@

\subsection{The ComiCal module}

\todoo{Describe this module}

<<lib/ComiCal.hs>>=
-- |
-- Module      : ComiCal
-- Description : The main API for ComiCal
-- Copyright   : (c) Eric Bailey, 2019-2021
-- License     : MIT
-- Maintainer  : eric@ericb.me
-- Stability   : stable
-- Portability : POSIX
module ComiCal
  ( dcIssues,
    imageCollections,
    imageIssues,
    marvelIssues,
    mkCalendar,
  )
where

<<ComiCal imports>>

<<Handle DC comics>>

<<Handle Image comics>>

<<Handle Marvel comics>>

@

<<lib/ComiCal.hs>>=
-- | Given a 'Series', create an 'Event' from each 'Release' and return a
-- 'Calendar'.
mkCalendar :: Series -> Calendar
mkCalendar series = Calendar (series ^. title) $ NE.map go (series ^. releases)
  where
    go :: Release -> Event
    go rel =
      Event (rel ^. date) (rel ^. slug) (rel ^. title) $
        fromMaybe (rel ^. uri) ((rel ^. uri) `relativeTo` (series ^. uri))
@ %def mkCalendar

<<ComiCal imports>>=
import ComiCal.App (Publisher (..), runComiCalApp)
import qualified ComiCal.DC as DC
import qualified ComiCal.Image as Image
import qualified ComiCal.Marvel as Marvel
import ComiCal.Types hiding (PullList (..))
import Control.Lens ((^.))
import qualified Data.List.NonEmpty as NE
import Data.Maybe (fromMaybe)
import Data.Text (Text)
import Text.URI (relativeTo)
@

<<Handle DC comics>>=
-- | Given a [DC Comics series](https://www.dccomics.com/comics) slug,
-- fetch, parse, and return the issues of the 'Series'.
dcIssues :: Text -> IO Series
dcIssues = runComiCalApp getIssues DC.publisher
@ %def dcIssues

<<Handle Image comics>>=
-- | Given an [Image Comics series](https://imagecomics.com/comics/series) slug,
-- fetch, parse, and return the collections of the 'Series'.
imageCollections :: Text -> IO Series
imageCollections = runComiCalApp getCollections Image.publisher

-- | Given an [Image Comics series](https://imagecomics.com/comics/series) slug,
-- fetch, parse, and return the issues of the 'Series'.
imageIssues :: Text -> IO Series
imageIssues = runComiCalApp getIssues Image.publisher
@ %def imageCollections
@ %def imageIssues

<<Handle Marvel comics>>=
-- | Given a [Marvel Comics series](https://www.marvel.com/comics) slug,
-- fetch, parse, and return the issues of the 'Series'.
marvelIssues :: Text -> IO Series
marvelIssues = runComiCalApp getIssues Marvel.publisher
@ %def marvelIssues

\subsection{Main}

<<app/Main.hs>>=
-- |
-- Module      : Main
-- Description : The main entrypoint for the ComiCal executable
-- Copyright   : (c) Eric Bailey, 2019-2021
-- License     : MIT
-- Maintainer  : eric@ericb.me
-- Stability   : stable
-- Portability : POSIX
module Main (main) where

<<imports>>

<<main>>

<<options parsing>>
@

Import the library API, qualified to avoid naming conflicts with the options parsing.

<<imports>>=
import qualified ComiCal
@

Import the PullList type from the library.

<<imports>>=
import ComiCal.Types (PullList (..))
@

Import liftIO from Control.Monad.Trans, to run the ComiCal app in the IO monad.

<<imports>>=
import Control.Monad.Trans (liftIO)
@

Import decodeFileStrict from Data.Aeson to parse a pull list from a JSON file.

<<imports>>=
import Data.Aeson (decodeFileStrict)
@

Import Options.Applicative to parse command line options.

<<imports>>=
import Options.Applicative
@


The pull list can be configure with a JSON file, or by flags.

<<options parsing>>=
data AppMode
  = FromFile FilePath
  | FromFlags PullList

@

Declare a parser for the command line options.

<<options parsing>>=
opts :: ParserInfo AppMode
opts =
  info (mkAppMode <**> helper) $
    fullDesc
      <> progDesc "Track the publish dates of comics"
      <> header "ComiCal - comics in your calendar"

@

Handle the app mode, i.e. configure the pull list from a JSON file, or from flags.

<<options parsing>>=
mkAppMode :: Parser AppMode
mkAppMode = FromFile <$> config <|> FromFlags <$> fromFlags
  where
    config =
      strOption
        ( (long "pull-list" <> short 'p')
            <> metavar "PULL_LIST"
            <> help "Pull list file (JSON)"
        )

@

Define the flags for configuring a pull list.

<<options parsing>>=
fromFlags :: Parser PullList
fromFlags =
  PullList
    <$> many
      ( strOption
          ( long "dc-collections"
              <> metavar "SLUG"
              <> help "Track collected editions of DC comics"
          )
      )
    <*> many
      ( strOption
          ( long "dc-issues"
              <> metavar "SLUG"
              <> help "Track single issues of DC comics"
          )
      )
    <*> many
      ( strOption
          ( long "image-collections"
              <> metavar "SLUG"
              <> help "Track collected editions of Image comics"
          )
      )
    <*> many
      ( strOption
          ( long "image-issues"
              <> metavar "SLUG"
              <> help "Track single issues of Image comics"
          )
      )
    <*> many
      ( strOption
          ( long "marvel-collections"
              <> metavar "SLUG"
              <> help "Track collected editions of Marvel comics"
          )
      )
    <*> many
      ( strOption
          ( long "marvel-issues"
              <> metavar "SLUG"
              <> help "Track single issues of Marvel comics"
          )
      )
@

Parse the flags to configure the pull list, then pull it, and output a calender
in ICS format.

<<main>>=
main :: IO ()
main =
  do
    appMode <- execParser opts
    pullList <- case appMode of
      FromFile fname ->
        liftIO $
          decodeFileStrict fname
            >>= maybe (error ("Failed to parse " <> fname)) pure
      FromFlags pullList -> pure pullList
    let pull = mapM . (fmap ComiCal.mkCalendar .)
    print . foldr1 (<>)
      =<< pull ComiCal.dcIssues (dcIssues pullList)
        <> pull ComiCal.imageCollections (imageCollections pullList)
        <> pull ComiCal.imageIssues (imageIssues pullList)
        <> pull ComiCal.marvelIssues (marvelIssues pullList)
@ %def main

\subsection{Package}

<<package.yaml>>=
name: ComiCal
version: !include "./VERSION"
synopsis: Track the publish dates of your favorite comics
author: Eric Bailey
maintainer: eric@ericb.me
github: yurrriq/ComiCal
extra-source-files:
- CHANGELOG.md
@

Declare dependencies common to the library and executable.
\begin{itemize}
\item \hrefootnote{https://hackage.haskell.org/package/aeson}{aeson}: Fast JSON parsing and encoding
\item \hrefootnote{https://hackage.haskell.org/package/base}{base}: The Standard Haskell Prelude and its support libraries
\item \hrefootnote{https://hackage.haskell.org/package/mtl}{mtl}: Monad classes, using functional dependencies
\end{itemize}

<<package.yaml>>=
dependencies:
- aeson
- base
- mtl
@

Use the OverloadedStrings extension by default, so as to avoid worrying about
type annotations for string literals.

<<package.yaml>>=
default-extensions:
- OverloadedStrings
- TemplateHaskell
@

Enable GHC to catch more issues at compile time.

<<package.yaml>>=
ghc-options:
- -Wall
- -Werror
- -Wincomplete-patterns
- -Wincomplete-uni-patterns
@

Configure the library.

<<package.yaml>>=
library:
  source-dirs: lib
  dependencies:
  - bytestring
  - composition-extra
  - exceptions
  - html-conduit
  - http-client
  - http-types
  - lens
  - modern-uri
  - monad-logger
  - req
  - tagsoup
  - text
  - time-compat
  - transformers
  - xml-conduit
@

Configure the executable.

<<package.yaml>>=
executable:
  ghc-options:
  - -O2
  source-dirs: app
  main: Main.hs
  dependencies:
  - ComiCal
  - optparse-applicative
@

<<Setup.hs>>=
import Distribution.Simple

main :: IO ()
main = defaultMain
@
